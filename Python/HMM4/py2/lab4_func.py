from __future__ import division
from __future__ import with_statement
from __future__ import absolute_import
import math
from io import open
########  FUNCTIONS  #######

# File Length
def file_len(fname):
    with open(fname) as f:
        for i, l in enumerate(f):
            pass
        return i+1

def getMat(rawDat, var):
    Mat = [rawDat[var][x+2:x+2+(rawDat[var][1])]
           for x in xrange(0, len(rawDat[var])-2, rawDat[var][1])]
    return Mat

def getVect(rawDat, var):
    Vect = rawDat[var][1:]
    return Vect

def getCol(A, column_num):
    col = [[i[column_num]] for i in A]
    return col

def getRow(A, row_num):
    row = A[row_num]
    return row

def printMat(Mat):
    for i in Mat:
        for j in i:
            print j,
        print u"\n"

# MATRIX MULTIPLICATOR
def matCalc(A,B):
    m = len(A)
    n = len(A[0])
    p = len(B)
    q = len(B[0])
    
    c = [[0 for j in xrange(q)] for i in xrange(m)]
    if n == p:
        for i in xrange(m):
            for j in xrange(q):
                for k in xrange(n):
                    c[i][j] = c[i][j]+(A[i][k]*B[k][j]);
    else:
        print u"Dimension error"
        return
    return c

# MATRIX TRANSPOSE
def transpose(A):
    trans = [[A[row][col] for row in xrange(0,len(A)) ] for col in xrange(0,len(A[0]))]
    return trans

# ELEMENT-WISE MULTIPLICATION
def elemWise(A,B, giveMatrixForm = False):
    res = []
    if len(A) == len(B):
        for i in xrange(len(A)):
            res.append(A[i]*B[i])
    else:
        print u"Dimension error"
    if giveMatrixForm == True:
        return [res]
    return res

# TRUNCATE
def truncate(number, digits):
    stepper = pow(10.0, digits)
    return math.trunc(stepper * number) / stepper


def ansFormat(A, mkstr = False, trunc = 1):
    m = len(A)
    n = len(A[0])

    str_list = []

    str_list.append(m)
    str_list.append(n)

    for i in xrange(m):
        for j in xrange(n):
            str_list.append(float(truncate(A[i][j],trunc)))
            #str_list.append(float(A[i][j]))

    if mkstr == True:
        return (u" ".join(unicode(i) for i in str_list)+u"\n")
    return str_list

# HMM2 - EVALUATION PROBLEM (a-PASS, FOWARD ALGORITHM)
u"""Given an HMM lambda (A,B, pi) and a sequence of obs. O
    what is the probability that the obs. are generated by the model p(O|lambda)"""

u"""Given Observations what is the probability of the given sequence"""
def EvalProb(A, B, pi, O):
    for i in xrange(len(O)):
        if i == 0:
            tk = elemWise(pi[0], transpose(getCol(B, O[i]))[0], giveMatrixForm = True)
        else:
            tk = elemWise(matCalc(tk, A)[0], transpose(getCol(B, O[i]))[0], giveMatrixForm = True)
        #print(tk)
    return sum(tk[0])

# HMM 3 - DECODING PROBLEM (VITERBI ALGORITHM)
u"""Given lambda (A, B, pi) and a sequence of obs. O, what is the most likely
    state sequence in the model that produced the sequence of O.

Most probable sequence of states given observations
"""
def Viterbi(At, Bt, Pt, Ot):
    sequence = []
    maxStates = []
    for k in xrange(len(Ot)): #Use len(Ot)
        if k == 0:
            tk = elemWise(Pt[0], transpose(getCol(Bt, Ot[k]))[0], giveMatrixForm = True)[0]
        else:
            problist = [[i*getCol(Bt,Ot[k])[j][0] for i in elemWise(tk,
                    transpose(getCol(At,j))[0])] for j in xrange(len(At[0]))]
            
            d_list = [max(i) for i in problist]
            elemOfMaxProb = [problist[j].index(d_list[j]) for j in xrange(len(At[0]))]
            tk = d_list

            maxStates.append(elemOfMaxProb)

    lastState = d_list.index(max(d_list))
    seq = [lastState]
    for i in reversed(xrange(len(maxStates))):

        seq.append(maxStates[i][lastState])
        lastState = maxStates[i][lastState]
    #print(d_list)
    return list(reversed(seq))

# MISC FUNCTIONS
def Lesson1Data():
    At = [[0.6, 0.1 ,0.1, 0.2], [0.0, 0.3, 0.2, 0.5],
      [0.8, 0.1, 0.0, 0.1], [0.2, 0.0, 0.1, 0.7]]
    Bt = [[0.6, 0.2, 0.1, 0.1], [0.1, 0.4, 0.1, 0.4],
      [0.0, 0.0, 0.7, 0.3], [0.0, 0.0, 0.1, 0.9]]
    Pt = [[0.5, 0, 0, 0.5]]
    Ot = [3, 0, 0, 2]
    return At, Bt, Pt ,Ot

def Lesson2Data():
    At = [[0.6, 0.1, 0.1, 0.2], [0.0, 0.3, 0.2, 0.5],
          [0.8, 0.1, 0.0, 0.1], [0.2, 0.0, 0.1, 0.7]]
    Bt = [[0.6, 0.2, 0.1, 0.1], [0.1, 0.4, 0.1, 0.4],
          [0.0, 0.0, 0.7, 0.3], [0.0, 0.0, 0.1, 0.9]]
    Pt = [[0.5, 0.0, 0.0, 0.5]]
    Ot = [2, 0, 3, 1]
    return At, Bt, Pt, Ot
    


u""" SOURCES
Three basic problems of HMMs
http://jedlik.phy.bme.hu/~gerjanos/HMM/node6.html 

"""
    
