import math
########  FUNCTIONS  #######

# File Length
def file_len(fname):
    with open(fname) as f:
        for i, l in enumerate(f):
            pass
        return i+1

def getMat(rawDat, var):
    Mat = [rawDat[var][x+2:x+2+(rawDat[var][1])]
           for x in range(0, len(rawDat[var])-2, rawDat[var][1])]
    return Mat

def getVect(rawDat, var):
    Vect = rawDat[var][1:]
    return Vect

def getCol(A, column_num):
    col = [[i[column_num]] for i in A]
    return col

def getRow(A, row_num):
    row = A[row_num]
    return row

def printMat(Mat):
    for i in Mat:
        for j in i:
            print(j, end = " " )
        print("\n")

# MATRIX MULTIPLICATOR
def matCalc(A,B):
    m = len(A)
    n = len(A[0])
    p = len(B)
    q = len(B[0])
    
    c = [[0 for j in range(q)] for i in range(m)]
    if n == p:
        for i in range(m):
            for j in range(q):
                for k in range(n):
                    c[i][j] = c[i][j]+(A[i][k]*B[k][j]);
    else:
        print("Dimension error")
        return
    return c

# MATRIX TRANSPOSE
def transpose(A):
    trans = [[A[row][col] for row in range(0,len(A)) ] for col in range(0,len(A[0]))]
    return trans

# ELEMENT-WISE MULTIPLICATION
def elemWise(A,B, giveMatrixForm = False):
    res = []
    if len(A) == len(B):
        for i in range(len(A)):
            res.append(A[i]*B[i])
    else:
        print("Dimension error")
    if giveMatrixForm == True:
        return [res]
    return res

# TRUNCATE
def truncate(number, digits) -> float:
    stepper = pow(10.0, digits)
    return math.trunc(stepper * number) / stepper


def ansFormat(A, mkstr = False):
    m = len(A)
    n = len(A[0])

    str_list = []

    str_list.append(m)
    str_list.append(n)

    for i in range(m):
        for j in range(n):
            str_list.append(float(truncate(A[i][j],1)))
            #str_list.append(A[i][j])

    if mkstr == True:
        return (" ".join(str(i) for i in str_list)+"\n")
    return str_list

# HMM2 - EVALUATION PROBLEM
"""Given an HMM lambda (A,B, pi) and a sequence of obs. O
    what is the probability that the obs. are generated by the model p(O|lambda)"""

def EvalProb(A, B, pi, O):
    for i in range(len(O)):
        if i == 0:
            tk = elemWise(pi[0], transpose(getCol(B, O[i]))[0], giveMatrixForm = True)
        else:
            tk = elemWise(matCalc(tk, A)[0], transpose(getCol(B, O[i]))[0], giveMatrixForm = True)
        #print(tk)
    return sum(tk[0])

# MISC FUNCTIONS
def Lesson1Data():
    At = [[0.6, 0.1 ,0.1, 0.2], [0.0, 0.3, 0.2, 0.5],
      [0.8, 0.1, 0.0, 0.1], [0.2, 0.0, 0.1, 0.7]]
    Bt = [[0.6, 0.2, 0.1, 0.1], [0.1, 0.4, 0.1, 0.4],
      [0.0, 0.0, 0.7, 0.3], [0.0, 0.0, 0.1, 0.9]]
    Pt = [[0.5, 0, 0, 0.5]]
    Ot = [3, 0, 0, 2]
    return At, Bt, Pt ,Ot

def Lesson2Data():
    At = [[0.6, 0.1, 0.1, 0.2], [0.0, 0.3, 0.2, 0.5],
          [0.8, 0.1, 0.0, 0.1], [0.2, 0.0, 0.1, 0.7]]
    Bt = [[0.6, 0.2, 0.1, 0.1], [0.1, 0.4, 0.1, 0.4],
          [0.0, 0.0, 0.7, 0.3], [0.0, 0.0, 0.1, 0.9]]
    Pt = [[0.5, 0.0, 0.0, 0.5]]
    Ot = [2, 0, 3, 1]
    return At, Bt, Pt, Ot
    


""" SOURCES
Three basic problems of HMMs
http://jedlik.phy.bme.hu/~gerjanos/HMM/node6.html 

"""
    
